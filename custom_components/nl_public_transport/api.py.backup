"""API client for Dutch Public Transport."""
from __future__ import annotations

import logging
from typing import Any
from datetime import datetime, timedelta

import aiohttp

from .gtfs import GTFSStopCache

_LOGGER = logging.getLogger(__name__)

OVAPI_BASE_URL = "http://v0.ovapi.nl"


class NLPublicTransportAPI:
    """API client for Dutch public transport services using OVAPI."""

    def __init__(self, session: aiohttp.ClientSession) -> None:
        """Initialize the API client."""
        self.session = session
        self._gtfs_cache = GTFSStopCache()
        self._gtfs_loaded = False

    async def get_journey(self, origin: str, destination: str, num_departures: int = 5, line_filter: str = "") -> dict[str, Any]:
        """Get departure information from OVAPI."""
        try:
            # Get real-time departures from origin stop
            url = f"{OVAPI_BASE_URL}/tpc/{origin}"
            
            _LOGGER.debug(f"Requesting OVAPI departures from {url}")
            
            async with self.session.get(url, timeout=10) as response:
                if response.status != 200:
                    error_text = await response.text()
                    _LOGGER.error(f"OVAPI returned status {response.status}: {error_text}")
                    return self._get_default_data()
                
                data = await response.json()
                
                # OVAPI returns: {stop_code: {"Stop": {...}, "Passes": {...}}}
                stop_data = data.get(origin, {})
                if not stop_data or "Passes" not in stop_data:
                    _LOGGER.warning(f"No departure data for stop {origin}")
                    return self._get_default_data()
                
                # Extract and filter departures
                departures = self._parse_ovapi_passes(
                    stop_data["Passes"], 
                    destination, 
                    line_filter,
                    num_departures
                )
                
                if not departures:
                    _LOGGER.warning(f"No matching departures found for stop {origin}")
                    return self._get_default_data()
                
                # Format response
                first_departure = departures[0]
                stop_info = stop_data.get("Stop", {})
                
                return {
                    "origin": stop_info.get("TimingPointName", origin),
                    "destination": first_departure["destination"],
                    "departure_time": first_departure["expected_departure"],
                    "arrival_time": first_departure.get("expected_arrival"),
                    "delay": first_departure["delay"],
                    "delay_reason": "",
                    "platform": "",
                    "vehicle_types": [first_departure["transport_type"]],
                    "coordinates": [],
                    "upcoming_departures": departures,
                    "alternatives": [],
                    "has_alternatives": len(departures) > 1,
                    "missed_connection": False,
                    "reroute_recommended": False,
                    "journey_description": [
                        f"Line {first_departure['line_number']} to {first_departure['destination']}"
                    ],
                }
                
        except Exception as err:
            _LOGGER.error(f"Error fetching OVAPI data: {err}", exc_info=True)
            return self._get_default_data()
    
    def _parse_ovapi_passes(
        self, 
        passes: dict[str, Any], 
        destination_filter: str,
        line_filter: str,
        limit: int
    ) -> list[dict[str, Any]]:
        """Parse and filter OVAPI pass data."""
        departures = []
        
        for pass_key, pass_data in passes.items():
            if not isinstance(pass_data, dict):
                continue
            
            # Skip passed/cancelled vehicles
            status = pass_data.get("TripStopStatus", "")
            if status in ["PASSED", "CANCELLED"]:
                continue
            
            # Get line number and destination
            line_number = str(pass_data.get("LinePublicNumber", ""))
            destination = pass_data.get("DestinationName50", "")
            
            # Apply filters
            if line_filter and line_filter not in line_number:
                continue
            
            if destination_filter and destination_filter.lower() not in destination.lower():
                # Don't filter by destination if it's the stop name
                pass
            
            # Calculate delay
            delay = self._calculate_ovapi_delay(pass_data)
            
            departures.append({
                "line_number": line_number,
                "destination": destination,
                "expected_departure": pass_data.get("ExpectedDepartureTime"),
                "expected_arrival": pass_data.get("ExpectedArrivalTime"),
                "target_departure": pass_data.get("TargetDepartureTime"),
                "target_arrival": pass_data.get("TargetArrivalTime"),
                "delay": delay,
                "transport_type": pass_data.get("TransportType", "BUS"),
                "status": status,
                "minutes_until_departure": self._minutes_until(pass_data.get("ExpectedDepartureTime")),
            })
        
        # Sort by expected departure time
        departures.sort(key=lambda x: x.get("expected_departure", ""))
        
        return departures[:limit]
    
    def _calculate_ovapi_delay(self, pass_data: dict) -> int:
        """Calculate delay in minutes from OVAPI data."""
        expected = pass_data.get("ExpectedDepartureTime")
        target = pass_data.get("TargetDepartureTime")
        
        if not expected or not target:
            return 0
        
        try:
            exp_dt = datetime.fromisoformat(expected.replace('Z', '+00:00'))
            tgt_dt = datetime.fromisoformat(target.replace('Z', '+00:00'))
            delay_seconds = (exp_dt - tgt_dt).total_seconds()
            return int(delay_seconds / 60)
        except Exception as err:
            _LOGGER.debug(f"Error calculating delay: {err}")
            return 0
    
    def _minutes_until(self, departure_time_str: str) -> int:
        """Calculate minutes until departure."""
        if not departure_time_str:
            return 0
        
        try:
            departure_dt = datetime.fromisoformat(departure_time_str.replace('Z', '+00:00'))
            now = datetime.now(departure_dt.tzinfo)
            delta = (departure_dt - now).total_seconds() / 60
            return max(0, int(delta))
        except Exception as err:
            _LOGGER.debug(f"Error calculating minutes until: {err}")
            return 0

    async def get_journey(self, origin: str, destination: str, num_departures: int = 5, line_filter: str = "") -> dict[str, Any]:
        """Get journey information between two stops."""
        try:
            # Using the public transport REST API
            url = f"{self._base_url}/journeys"
            params = {
                "from": origin,
                "to": destination,
                "results": num_departures * 2 if line_filter else num_departures,  # Get more if filtering
                "stopovers": "true",
                "transfers": -1,  # Include all transfer options
            }
            
            _LOGGER.debug(f"Requesting journeys: {url} with params: {params}")
            
            async with self.session.get(url, params=params, timeout=15) as response:
                if response.status != 200:
                    error_text = await response.text()
                    _LOGGER.error(f"API returned status {response.status}: {error_text}")
                    return self._get_default_data()
                
                data = await response.json()
                
                if not data.get("journeys"):
                    _LOGGER.warning(f"No journeys found in API response for {origin} -> {destination}")
                    return self._get_default_data()
                
                # Filter journeys by line numbers if specified
                journeys = data["journeys"]
                if line_filter:
                    journeys = self._filter_journeys_by_line(journeys, line_filter)
                    if not journeys:
                        _LOGGER.warning(f"No journeys found matching line filter: {line_filter}")
                        return self._get_default_data()
                
                # Limit to requested number of departures after filtering
                journeys = journeys[:num_departures]
                
                # Parse all journey alternatives
                primary_journey = self._parse_journey(journeys[0])
                
                # Parse all departures for display
                all_departures = []
                for journey in journeys:
                    departure_info = self._parse_departure_info(journey)
                    all_departures.append(departure_info)
                
                primary_journey["upcoming_departures"] = all_departures
                
                # Add alternative routes (for rerouting purposes)
                alternatives = []
                for journey in journeys[1:5]:  # Get up to 4 alternatives
                    alt = self._parse_journey(journey)
                    alternatives.append(alt)
                
                primary_journey["alternatives"] = alternatives
                primary_journey["has_alternatives"] = len(alternatives) > 0
                
                # Check if reroute needed due to delays
                primary_journey["reroute_recommended"] = self._should_reroute(
                    primary_journey, alternatives
                )
                
                return primary_journey
                
        except Exception as err:
            _LOGGER.error(f"Error fetching journey data: {err}")
            return self._get_default_data()

    async def search_location(self, query: str) -> list[dict[str, Any]]:
        """Search for locations/stops using both GTFS (bus/tram) and REST API (trains)."""
        # Load GTFS cache if not already loaded
        if not self._gtfs_loaded:
            await self._gtfs_cache.load()
            self._gtfs_loaded = True
        
        # Search GTFS stops (buses, trams, metro) - already labeled
        gtfs_results = self._gtfs_cache.search(query, limit=100)
        
        # Search REST API for train stations and add labels
        train_results = await self._search_train_stations(query)
        
        # Combine results: GTFS first (local transport), then trains
        all_results = gtfs_results + train_results
        
        # Remove duplicates based on name similarity
        unique_results = self._deduplicate_results(all_results)
        
        _LOGGER.info(f"Found {len(unique_results)} locations for query '{query}' ({len(gtfs_results)} local, {len(train_results)} trains)")
        return unique_results
    
    async def _search_train_stations(self, query: str) -> list[dict[str, Any]]:
        """Search for train stations using the REST API."""
        try:
            url = f"{self._base_url}/locations"
            params = {"query": query, "results": 50}
            
            _LOGGER.debug(f"Searching train stations: {url}?query={query}")
            
            async with self.session.get(url, params=params, timeout=10) as response:
                if response.status != 200:
                    error_text = await response.text()
                    _LOGGER.error(f"Train station API returned status {response.status}: {error_text}")
                    return []
                
                data = await response.json()
                
                # Filter for actual stations and add type labels
                locations = []
                for loc in data:
                    if not loc.get("name"):
                        continue
                    
                    loc_type = loc.get("type", "unknown")
                    name = loc.get("name")
                    
                    # Add transport type label based on type
                    if loc_type == "station":
                        labeled_name = f"{name} (Train Station)"
                    elif loc_type == "stop":
                        labeled_name = f"{name} (Train Stop)"
                    else:
                        continue  # Skip non-train locations
                    
                    locations.append({
                        "id": loc.get("id"),
                        "name": labeled_name,
                        "latitude": loc.get("latitude"),
                        "longitude": loc.get("longitude"),
                        "type": loc_type,
                    })
                
                return locations
                
        except Exception as err:
            _LOGGER.error(f"Error searching train stations: {err}", exc_info=True)
            return []
    
    def _deduplicate_results(self, results: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Remove duplicate results based on exact name match."""
        seen_names = set()
        unique = []
        
        for result in results:
            name = result.get("name", "").strip()
            # Keep exact duplicates separate (e.g., different types at same location)
            if name and name not in seen_names:
                seen_names.add(name)
                unique.append(result)
        
        return unique

    def _parse_journey(self, journey: dict[str, Any]) -> dict[str, Any]:
        """Parse journey data from API response."""
        legs = journey.get("legs", [])
        
        if not legs:
            return self._get_default_data()
        
        first_leg = legs[0]
        last_leg = legs[-1]
        
        departure = first_leg.get("departure")
        arrival = last_leg.get("arrival")
        
        # Check all legs for delays
        total_delay = 0
        delay_reasons = []
        missed_connection = False
        
        for i, leg in enumerate(legs):
            leg_delay = 0
            if leg.get("departureDelay"):
                leg_delay = leg["departureDelay"] / 60
                total_delay = max(total_delay, leg_delay)
            
            if leg.get("arrivalDelay"):
                arr_delay = leg["arrivalDelay"] / 60
                total_delay = max(total_delay, arr_delay)
            
            # Check for missed connections
            if i < len(legs) - 1 and leg_delay > 0:
                next_leg = legs[i + 1]
                connection_time = self._calculate_connection_time(leg, next_leg)
                if connection_time < 2:  # Less than 2 minutes
                    missed_connection = True
            
            # Collect delay reasons
            if leg.get("remarks"):
                for remark in leg["remarks"]:
                    if remark.get("type") in ["warning", "status"]:
                        text = remark.get("text") or remark.get("summary")
                        if text and text not in delay_reasons:
                            delay_reasons.append(text)
        
        delay_reason = "; ".join(delay_reasons) if delay_reasons else None
        
        # Parse route coordinates
        coordinates = []
        for leg in legs:
            if leg.get("origin", {}).get("location"):
                loc = leg["origin"]["location"]
                coordinates.append([loc.get("latitude"), loc.get("longitude")])
            if leg.get("destination", {}).get("location"):
                loc = leg["destination"]["location"]
                coordinates.append([loc.get("latitude"), loc.get("longitude")])
        
        # Get vehicle types and create journey description
        vehicle_types = []
        journey_description = []
        for leg in legs:
            product = leg.get("line", {}).get("product", "Walk")
            line_name = leg.get("line", {}).get("name", "Walk")
            origin_name = leg.get("origin", {}).get("name", "")
            dest_name = leg.get("destination", {}).get("name", "")
            
            vehicle_types.append(product)
            journey_description.append(f"{product} {line_name}: {origin_name} â†’ {dest_name}")
        
        return {
            "departure_time": departure,
            "arrival_time": arrival,
            "delay": total_delay,
            "delay_reason": delay_reason,
            "platform": first_leg.get("departurePlatform"),
            "vehicle_types": vehicle_types,
            "coordinates": coordinates,
            "on_time": total_delay <= 0,
            "missed_connection": missed_connection,
            "journey_description": journey_description,
            "legs": self._parse_legs(legs),
        }
    
    def _parse_legs(self, legs: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Parse individual journey legs."""
        parsed_legs = []
        for leg in legs:
            line_info = leg.get("line", {})
            parsed_legs.append({
                "origin": leg.get("origin", {}).get("name"),
                "destination": leg.get("destination", {}).get("name"),
                "departure": leg.get("departure"),
                "arrival": leg.get("arrival"),
                "product": line_info.get("product", "Walk"),
                "line": line_info.get("name", ""),
                "line_id": line_info.get("id", ""),
                "platform": leg.get("departurePlatform"),
                "delay": (leg.get("departureDelay") or 0) / 60,
            })
        return parsed_legs
    
    def _parse_departure_info(self, journey: dict[str, Any]) -> dict[str, Any]:
        """Parse simplified departure information for upcoming departures list."""
        legs = journey.get("legs", [])
        if not legs:
            return {}
        
        first_leg = legs[0]
        last_leg = legs[-1]
        
        # Calculate total delay
        total_delay = 0
        for leg in legs:
            if leg.get("departureDelay"):
                leg_delay = leg["departureDelay"] / 60
                total_delay = max(total_delay, leg_delay)
            if leg.get("arrivalDelay"):
                arr_delay = leg["arrivalDelay"] / 60
                total_delay = max(total_delay, arr_delay)
        
        # Get vehicle types and line names
        vehicle_types = []
        line_names = []
        for leg in legs:
            line_info = leg.get("line", {})
            product = line_info.get("product", "")
            line_name = line_info.get("name", "")
            
            if product and product not in vehicle_types and product != "walking":
                vehicle_types.append(product)
            
            if line_name and line_name not in line_names:
                line_names.append(line_name)
        
        return {
            "departure_time": first_leg.get("departure"),
            "arrival_time": last_leg.get("arrival"),
            "delay": total_delay,
            "platform": first_leg.get("departurePlatform"),
            "vehicle_types": vehicle_types,
            "line_names": line_names,
            "on_time": total_delay <= 0,
        }
    
    def _filter_journeys_by_line(self, journeys: list[dict[str, Any]], line_filter: str) -> list[dict[str, Any]]:
        """Filter journeys by specific line numbers."""
        # Parse line filter - support comma-separated values
        filter_lines = [line.strip().upper() for line in line_filter.split(",")]
        
        filtered = []
        for journey in journeys:
            legs = journey.get("legs", [])
            # Check if any leg matches the line filter
            for leg in legs:
                line_name = leg.get("line", {}).get("name", "")
                line_product = leg.get("line", {}).get("product", "")
                
                # Match against line name or product
                for filter_line in filter_lines:
                    if (filter_line in line_name.upper() or 
                        filter_line in line_product.upper() or
                        filter_line == str(leg.get("line", {}).get("fahrtNr", "")).upper()):
                        filtered.append(journey)
                        break
                if journey in filtered:
                    break
        
        return filtered
    
    def _calculate_connection_time(self, leg1: dict, leg2: dict) -> float:
        """Calculate connection time between two legs in minutes."""
        try:
            arr_time = datetime.fromisoformat(leg1.get("arrival", "").replace("Z", "+00:00"))
            dep_time = datetime.fromisoformat(leg2.get("departure", "").replace("Z", "+00:00"))
            return (dep_time - arr_time).total_seconds() / 60
        except Exception:
            return 999  # Return large number if can't calculate
    
    def _should_reroute(self, primary: dict[str, Any], alternatives: list[dict[str, Any]]) -> bool:
        """Determine if rerouting is recommended."""
        # Reroute if:
        # 1. Primary route has significant delay (>10 min)
        # 2. Missed connection detected
        # 3. Alternative is significantly faster
        
        if primary.get("missed_connection"):
            return True
        
        if primary.get("delay", 0) > 10:
            # Check if any alternative is at least 5 minutes faster
            try:
                primary_arrival = datetime.fromisoformat(
                    primary.get("arrival_time", "").replace("Z", "+00:00")
                )
                for alt in alternatives:
                    alt_arrival = datetime.fromisoformat(
                        alt.get("arrival_time", "").replace("Z", "+00:00")
                    )
                    time_diff = (primary_arrival - alt_arrival).total_seconds() / 60
                    if time_diff > 5:  # Alternative is 5+ min faster
                        return True
            except Exception:
                pass
        
        return False

    def _get_default_data(self) -> dict[str, Any]:
        """Return default data structure."""
        return {
            "departure_time": None,
            "arrival_time": None,
            "delay": 0,
            "delay_reason": None,
            "platform": None,
            "vehicle_types": [],
            "coordinates": [],
            "on_time": True,
            "missed_connection": False,
            "journey_description": [],
            "legs": [],
            "alternatives": [],
            "has_alternatives": False,
            "reroute_recommended": False,
            "upcoming_departures": [],
        }
